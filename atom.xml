<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tangliang&#39;s Blog</title>
  
  <subtitle>生活的洪流欲让人们窒息，我们却在缺氧的环境中肆意成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-10T11:09:32.410Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>不会唱丁香花</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue前后端分离初体验</title>
    <link href="http://yoursite.com/2018/10/10/a/"/>
    <id>http://yoursite.com/2018/10/10/a/</id>
    <published>2018-10-10T10:21:27.000Z</published>
    <updated>2018-10-10T11:09:32.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端技术</p><ul><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js</a></li><li><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue-router</a>(Vue Router 是 Vue.js  官方的路由管理器)</li><li>axios</li><li><a href="http://element.eleme.io/#/zh-CN" target="_blank" rel="noopener">element-ui</a></li></ul><p>后端技术</p><ul><li>springboot</li><li>mybatis</li><li>shiro</li></ul><h3 id="生成vue项目"><a href="#生成vue项目" class="headerlink" title="生成vue项目"></a>生成vue项目</h3><p><strong>1 安装node.js</strong></p><p>​    具体安装流程还是要去看<code>node.js</code>官网。如果安装完成，请在终端输入<code>npm -v</code>查看是否安装成功。</p><p><strong>2、安装VueCLI脚手架</strong></p><p><code>VueCLI</code>能够帮助我们快速搭建一个webpack的项目。</p><p>在已经安装好<code>node.js</code>的前提上，在终端输入：<code>npm install vue-cli -g</code>开始安装VueCLI。如果安装完成，请在终端输入：vue查看是否安装成功</p><p>3 用 cmd 进入到你要存放项目的目录，我把项目放在D盘的VueProject文件夹下，运行 vue init webpack 你的项目名</p><p><img src="/2018/10/10/a/捕获.jpg" alt="捕获"></p><blockquote><p>依次为你的项目名称，项目描述，作者，</p><p>nstall vue-router? (Y/n) </p><p>是否安装vue-router，这是官方的路由，大多数情况下都使用</p><p>Use ESLint to lint your code? (Y/n) </p><p>是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车</p><p>Setup unit tests with Karma + Mocha? (Y/n)</p><p> 是否安装单元测试</p><p>Setup e2e tests with Nightwatch(Y/n)? </p><p>是否安装e2e测试</p></blockquote><p>建议新手开始除了ESlint选no以外其他全部选yes，为什么？</p><p>开了之后你就会发现多一个空格，多一个换行，都瞎几把标红，很蛋疼</p><p>配置完成之后你会发现项目存放处会多了一个tldemo文件夹，这就是你的前端项目了</p><p><code>cd tldemo</code></p><p><code>npm install</code> :安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。</p><p><code>npm run dev</code></p><p><img src="/2018/10/10/a/1捕获.jpg" alt="1捕获"></p><p>好了，一个vue项目的HelloWord就出来了</p><h3 id="前端项目"><a href="#前端项目" class="headerlink" title="前端项目"></a>前端项目</h3><p>安装element-ui和axios</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install element-ui</span><br><span class="line"></span><br><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>前端项目目录</p><p><img src="/2018/10/10/a/2捕获.jpg" alt="2捕获"></p><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router/index.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">c</span> =&gt;</span> c(App),</span><br><span class="line">  router: router <span class="comment">//注册router</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>main是webpack入口文件，这里我们引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></table></figure><p><strong>路由 index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'../components/home'</span></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'../components/login'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">const</span> routes= [   </span><br><span class="line">    &#123; <span class="attr">path</span> :<span class="string">'/'</span>,<span class="attr">component</span> :login&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/home'</span>,<span class="attr">component</span>: home&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> router=<span class="keyword">new</span> Router(&#123;   </span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>如上就配置了，如果你访问<code>localhost:8081/</code>，那么就会自动路由跳转到<code>login.vue</code>组件中，提示我们登录;其中的<code>/home</code>表示，如果登录成功，就跳转到<code>home.vue</code>组件中，相当于登录成功后跳转到后台页面。</p><p><strong>登录组件 login.vue</strong></p><p><img src="/2018/10/10/a/temp.jpg" alt="temp"></p><p><img src="/2018/10/10/a/data.jpg" alt="data"></p><p><img src="/2018/10/10/a/meth.jpg" alt="meth">每个vue组件都是由三部分组成 <template>模板,<script>js代码,<style>样式</p><p>在上面表单中，我们只需要关注</p><p>v-model=”loginForm.username”</p><p>v-model=”loginForm.password”</p><p>@click=”submitForm(‘loginForm’)”</p><p>@click=”resetForm(‘loginForm’)”</p><p>首先this.$refs[loginForm].validate((valid)是element-ui提供的表单校验逻辑，</p><p>校验成功后通过axios发送post请求，请求成功，调用<code>.then()</code>回获取到成功的请求结果。index是从后端成功返回的结果，如果登陆成功就调用路由 $router.push({path :’home’})跳转到home组件（核心部分）</p><p>home组件home.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;这是首页&lt;<span class="regexp">/h2&gt;     </span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">        name:"home"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p><strong>前端界面</strong><img src="a\3捕获.jpg" alt="3捕获"></p><p>这时打开前端项目中的index.html<img src="a\7捕获.jpg" alt="7捕获"></p><p>首页中没有引入js，css代码，但页面视图是怎样渲染出来的，</p><p>没错就是通过我们.vue组件渲染出来的，是不是很有意思</p><p><strong>跨域请求的问题</strong></p><p><code>node.js</code>提供的web服务器地址是：<code>127.0.0.1:8081</code>，但是我们后端Tomcat服务器的地址是：<code>127.0.0.1:8080</code>，而默认是不能在一个域中访问另一个域中的资源的，所以也就出现了跨域请求的概念。</p><p>解决跨域请求的方式也有很多，我这里在后端controller上加了@CrossOrigin注解</p><h3 id="后端项目"><a href="#后端项目" class="headerlink" title="后端项目"></a>后端项目</h3><p>后端项目就相对比较简单，直接使用MyBatis Generator</p><p>MyBatis Generator 是MyBatis 官方出品的一款，用来自动生成MyBatis的 mapper、dao、entity 的框架，让我们省去规律性最强的一部分最基础的代码编写。</p><p>项目目录</p><p><img src="a\4捕获.jpg" alt="4捕获"></p><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserloginMapper userloginMapper;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestBody Map map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String username=map.get(<span class="string">"username"</span>).toString();</span><br><span class="line">        String password =map.get(<span class="string">"password"</span>).toString();</span><br><span class="line"></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken Token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行登录</span></span><br><span class="line">            subject.login(Token);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="string">"login"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了shiro安全框架具体请看<a href="http://jinnianshilongnian.iteye.com/blog/2049092">张开涛《跟我学Shiro》</a></p><p>需要注意的是我这里用@RequestBody，之前用@RequestParam来接收前端传过来的参数，居然接受不到，用postman测的没问题，很纳闷</p><p>请求正文为Request Payload,请求头Content-Type: application/json，以这种方式请求，后台用@RequestParam是接收不到参数的，只能用@RequestBody，而axios默认是用Content-Type: application/json，这问题可以在前端解决，也可以在后端解决，在前端解决需要修改axios的默认配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><p>Request Payload请求：</p><p>Request Payload的请求正文格式是json格式的字符串： </p><p>{ “loginName” : “admin”, “password” : “123456” }</p><p><img src="a\20170622173410846.jpg" alt="20170622173410846"></p><p>Form Data请求： </p><p>Form Data的请求正文格式是用key=value&amp;key1=value2格式： </p><p>loginName=admin&amp;password=123456</p><p><img src="a\20170622173833725.jpg" alt="20170622173833725"></p><p>这里是深坑，坑了我好长时间</p><p>请求成功</p><p><img src="a\6捕获.jpg" alt="6捕获"></p><p>好的一个简单的前后端分离登录功能就完成了</p></script></template></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="http://yoursite.com/2018/09/11/linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/11/linux基础/</id>
    <published>2018-09-11T14:42:03.000Z</published>
    <updated>2018-09-11T14:56:55.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在折腾Linux，之前大二学的忘得一干二净（其实考试也才刚及格，哈哈哈哈哈），重新看看吧。</p><p><a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>是一个开源、免费的<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是巨型项目都在使用<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">linux</a>。</p><p>​      linux的特点<br>​          - 免费的/开源<br>​          - 支持多线程/多用户<br>​          - 安全性好<br>​          - 对内存和文件管理优越 </p><p><strong>关机命令</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now（立即进行关机）     </span><br><span class="line">shutdown -r now （现在重新启动计算机）   </span><br><span class="line">reboot （现在重新启动计算机）</span><br></pre></td></tr></table></figure><p><strong>进入桌面 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><p><strong>用户登录 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录时尽量少用root账户登录，因为它是系统管理员，最大的权限，难免操作失误。</span><br><span class="line">可以利用普通用户登录，登录后再用“su -”命令来切换成系统管理员身份</span><br></pre></td></tr></table></figure><p><strong>用户注销 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在提示符下输入logout即可</span><br></pre></td></tr></table></figure><p>   vi编辑器是linux下最有名的编辑器，也是我们学习linux必须掌握的工具，在linux下也可使用vi进行程序的开发，如<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>程序，c程序 。输入i，进入到插入模式；输入Esc键，进入命令模式 ；输入冒号:wq 表示退出保存，:q!表示退出不保存</p><p><strong>linux的文件系统是采用层级式的树状目录结构</strong>，在此结构中的最上层是<strong>根目录“/”</strong>，然后在此目录下再创建其他的目录，深刻理解linux文件目录是非常重要的 </p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- / </span><br><span class="line">- root，存放root用户的相关文件 </span><br><span class="line">- home，存放普通用户的相关文件 </span><br><span class="line">- bin，存放常用命令的目录，如vi，su </span><br><span class="line">- sbin，要具有一定权限才可以使用命令 </span><br><span class="line">- mnt，默认挂载光驱和软驱的目录 </span><br><span class="line">- etc，存放配置的相关文件 </span><br><span class="line">- var，存放经常变化的文件，如网络连接的sock文件 </span><br><span class="line">- boot，存放引导系统启动的相关文件 </span><br><span class="line">- usr，安装一个软件的默认目录，相当于windows下的program files</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p><strong>常用命令介绍 </strong></p><p><strong>pwd</strong>，显示当前在哪个路径下 </p><p><strong>linux的用户管理</strong> </p><p><strong>useradd</strong> 用户名，添加用户<br>​      【案例】useradd xiaoming</p><p><strong>passwd</strong> 用户名，为新用户设密码<br>​      【案例】passwd xiaoming，修改小明的密码 </p><p><strong>userdel</strong> 用户名，删除用户<br>​      【案例】userdel xiaoming，删除用户但保存用户主目录<br>​      【案例】userdel ‐ xiaoming，删除用户以及用户主目录 </p><p><strong>logout</strong>，当前用户推出<br><strong>who am i</strong>，当前用户是谁<br><strong>cd</strong>，改变目录<br><strong>ls</strong>，列出文件和目录<br><strong>ls ‐a</strong>，显示目录下的所有文件，包括隐藏文件<br><strong>ls ‐l</strong>，显示长列表格式<br><strong>mkdir</strong>，建立目录<br><strong>rmdir</strong>，删除空目录<br><strong>touch</strong>，建立空文件 </p><p><strong>cp</strong>，复制命令<br>​      【案例】cp ‐r dir1 dir2，递归复制命令（复制子目录信息） </p><p><strong>mv</strong>，移动文件和改文件名<br><strong>rm</strong>，删除文件和目录<br><strong>rm ‐rf *</strong>，删除所有内容，包含目录和文件，r表示递归，f表示强制<br><strong>ln</strong>，建立符号连接，类似于建立某个文件的快捷方式 </p><p><strong>ln ‐s</strong> 源目标<br>​      【案例】ln ‐s /etc/inittab inittab，inittab指向实际文件/etc/inittab inittab </p><p><strong>more</strong>，显示文件内容带分页，ctrl + page up上翻，长空格下翻<br><strong>less</strong>，显示文件内容带分页 </p><p><strong>grep</strong>，在文本中查询内容<br>​      【案例】假设存在某个文件test.<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>中含有hanyang关键字，此时可以使用grep名命令来查找，   grep n “hanyang” test.java，n表示在第n行出现 </p><p><strong>|</strong>，管道命令，在linux和unix系统，把上一个命令的结果交给|后面的命令处理<br>​      【案例】ls ‐l /etc/ | more </p><p>man [command]，帮助，类似于dos中的help </p><p>find，搜索文件及目录。在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而“find”命令可以解决上述问题 </p><ul><li><strong>在特定的目录下搜索并显示指定名称的文件和目录</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【案例】find / -name man：意思是说从根目录开始搜索名称为man的文件或目录 </span><br><span class="line">- 搜索一段时间内被存取/变更的文件或目录 </span><br><span class="line">【案例】find /home -amin -10：十分钟内存取的文件或目录 </span><br><span class="line">【案例】find /home -atime -10：十小时内存取的文件或目录 </span><br><span class="line">【案例】find /home -cmin -10：十分钟内更改过的文件或目录 </span><br><span class="line">【案例】find /home -ctime +10：十小时前更改过的文件或目录</span><br></pre></td></tr></table></figure><ul><li><strong>搜索指定大小的文件</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【案例】find /home -size +10k：意思是说查找/home目录下大小为10k的文件</span><br></pre></td></tr></table></figure><ul><li><strong>重定向命令 </strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- ls -l &gt; a.txt，列表的内容写入文件a.txt中（覆盖写） </span><br><span class="line">- ls -al &gt;&gt; aa.txt，列表的内容追加到文件aa.txt的末尾 </span><br><span class="line">- 从文件中输入信息：database_program &lt; database_data </span><br><span class="line">- en，查看环境变量</span><br></pre></td></tr></table></figure><ul><li><strong>压缩和解压</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- 以zip和unzip处理.zip文件 </span><br><span class="line">- zip命令的基本使用方法 </span><br><span class="line">- zip file.zip *：zip后接压缩后的文件名，在它的后面输入要压缩的文</span><br><span class="line">件即可 </span><br><span class="line">- 压缩后，自动删除原文件 </span><br><span class="line">【案例】zip m file.zip to.txt：把to.txt文件压缩成file.zip文件，to.txt会自动删除的 </span><br><span class="line">- 将子目录一起压缩 </span><br><span class="line">【案例】zip ‐r file.zip *：将当前目录下的子目录一起压缩 </span><br><span class="line">- 忽略子目录的内容 </span><br><span class="line">【案例】zip ‐j file.zip * </span><br><span class="line">- 将已压缩的或没有必要压缩的文件去掉 </span><br><span class="line">【案例】zip ‐n .mpg: .jpg: .gif：第一种文件中间要用“：”分开 </span><br><span class="line">- 压缩某一日之后的文件 </span><br><span class="line">【案例】zip ‐t 102002 file.zip：将当前目录下在2002年10月20日之后文件压缩 </span><br><span class="line">- 不压缩链接文件的原文件 </span><br><span class="line">【案例】zip ‐y file.zip * </span><br><span class="line">- 压缩率问题，-1~-9，其中-9的压缩率最高 </span><br><span class="line">【案例】zip -9 file.zip * </span><br><span class="line">- 将不需要压缩的文件排除在外 </span><br><span class="line">【案例】zip file.zip * -x file2.txt：在压缩时，将当前目录内的file2.txt文件排除在外 </span><br><span class="line">- 以unzip命令进行.zip文件的解压缩 </span><br><span class="line">- 直接解压缩文件 </span><br><span class="line">【案例】unzip file.zip </span><br><span class="line">- 排除不需要解压缩的文件 </span><br><span class="line">【案例】unzip file.zip ‐x file2：除了file2文件外，其他的文件都解压缩 </span><br><span class="line">- 查看压缩包的内容 </span><br><span class="line">【案例】unzip ‐Z file.zip：查看file.zip压缩包的内容，也可以使用“-l” “-v”来查看压缩包的内容 </span><br><span class="line">- 以gzip和gunzip处理.gz文件</span><br></pre></td></tr></table></figure><p>​      在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有<strong>所有者、所在组、其它组</strong>的概念 。<br>1）所有者：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者。用ls ‐ahl命令可以看到文件的所有者。也可以使用chown 用户名 文件名来修改文件的所有者。<br>2）文件所在组：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组，用ls ‐ahl命令可以看到文件的所有组，也可以使用chgrp 组名 文件名来修改文件所在的组。<br>3）其它组：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p><p><strong>文件权限 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ls -l中显示的内容如下： </span><br><span class="line">      -rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc </span><br><span class="line"></span><br><span class="line">- 10个字符确定不同用户能对文件干什么 </span><br><span class="line">- 第一个字符代表文件（-）、目录（d），链接（l） </span><br><span class="line">- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x） </span><br><span class="line">- 第一组rwx：文件所有者的权限是读、写和执行 </span><br><span class="line">- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行 </span><br><span class="line">- 第三组r--：不与文件所有者同组的其他用户的权限是读不能写和执行 </span><br><span class="line">也可用数字表示为：r=4，w=2，x=1 因此rwx=4+2+1=7 </span><br><span class="line"></span><br><span class="line">- 1 表示连接的文件数 </span><br><span class="line">- root 表示用户 </span><br><span class="line">- root表示用户所在的组 </span><br><span class="line">- 1213 表示文件大小（字节） </span><br><span class="line">- Feb 2 09:39 表示最后修改日期 </span><br><span class="line">- abc 表示文件名</span><br></pre></td></tr></table></figure><p><strong>改变权限的命令</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod 改变文件或目录的权限 </span><br><span class="line">chmod 755 abc：赋予abc权限rwxr-xr-x </span><br><span class="line">chmod u=rwx，g=rx，o=rx abc：同上u=用户权限，g=组权限，o=不同组其他用户权限 </span><br><span class="line">chmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限 </span><br><span class="line">chmod a+r abc：给所有用户添加读的权限</span><br></pre></td></tr></table></figure><p><strong>改变所有者（chown）和用户组（chgrp）命令 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chown xiaoming abc：改变abc的所有者为xiaoming </span><br><span class="line">chgrp root abc：改变abc所属的组为root </span><br><span class="line">chown root ./abc：改变abc这个目录的所有者是root </span><br><span class="line">chown ‐R root ./abc：改变abc这个目录及其下面所有的文件和目录的所有者是root</span><br></pre></td></tr></table></figure><p><strong>改变用户所在组 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在添加用户时，可以指定将该用户添加到哪个组中，同样用root的管理权限可以改变某个</span><br><span class="line">用户所在的组 </span><br><span class="line">- usermod ‐g 组名 用户名 </span><br><span class="line">你可以用 - usermod ‐d 目录名 用户名，改变该用户登录的初始目录</span><br></pre></td></tr></table></figure><p><strong>linux分区详解 </strong><br>硬盘的分区主要分为基本分区（Primary Portion）和扩展分区（Extension Portion）两种。</p><p>只是针对一个硬盘来讲，基本分区和扩展分区的数目之和不能大于4个，且基本分区可以马上被使用但不能再分区。扩展分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。那么有扩展分区再分下去的是什么呢？它就是逻辑分区（Logical Portion），而且逻辑分区没有数量上限制 对windows用户来说，有几个分区就有几个驱动器，并且每个分区都会获得一个字母标识符，然后就可以选用这个字母来指定在这个分区上的文件和目录。它们的文件结构都是独立的，非常好理解。但对这些用户初上手Redhat Linux，可就有点恼人了。</p><p>因为对<strong>Redhat Linux用户来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录、一个独立且唯一的文件结构</strong>。Redhat Linux中每个分区都是用来组成整个文件系统的一部分。因为它<strong>采用了一种叫“载入”的处理方法</strong>，它的整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来。这时要载入的那个分区将使它的存储空间在这个目录下获得。</p><p>几个重要命令 </p><p><strong>挂载命令 </strong><br>mount [-parameters][设备名称] [挂载点] </p><p><strong>卸载命令 </strong><br>umount [挂载点] </p><p><strong>查看磁盘使用情况 </strong><br>df [-parameters]<br>- df -h<br>- df ‐l<br>- df [目录全路径]，查看某个目录是在哪个分区 </p><p><strong>查看linux系统分区具体情况 </strong><br>fdisk ‐l </p><p><strong>shell编程 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其实作为命令语言互动式地解释和执行用户输入的命令只是shell功能的一个方面。shell还可以用来进行程序设计。它提供了定义变量和参数的手段以及丰富的程序控制结构。使用shell编程类似于DOS中批处理文件，称为shell</span><br><span class="line"> script，又叫shell程序或shell命令文件。</span><br><span class="line">shell脚本文件： </span><br><span class="line">- 是一个文本文件 </span><br><span class="line">- 命令的集合 </span><br><span class="line">- 有执行的权限 </span><br><span class="line">- 执行方式（./文件名） </span><br><span class="line">用export可以临时加入一个系统路径，如export PATH=$PATH:$HOME/bin:/root/test/t1，输出环境PATH，引用原来的值$，PATH，$HOME表示工作主目录，:是路径分隔符</span><br></pre></td></tr></table></figure><p><strong>shell通配符 </strong><br>- <em>代表多个字母或数字<br>- ?代表一个字母或数字<br>【案例】ls a</em> ls a? ls f080[1-6].tif </p><p><strong>- 转义字符\ </strong></p><p>【案例】ls /mnt/win1/My\Documents </p><p><strong>- 单引号：不处理任何变量和命令 </strong></p><p>【案例】echo ‘Welcome $NAME, the date is date ’ </p><p><strong>- 双引号：处理变量但不处理命令</strong> </p><p>【案例】echo “Welcome $NAME, the date is date “ </p><p><strong>- 反引号：把引号中的每个单词作为一个命令，如果是变量则先求值然后作为一个命令处理 </strong></p><p>【案例】echo “Welcome $NAME, the date is <code>date</code> “ </p><p><strong>查阅历史记录 </strong><br>- history，查看使用过的命令的历史记录<br>- history 5，此项说明会显示最近使用的5个命令<br>- !5，此项说明执行历史编号为5的命令 </p><p>- !ls，此项说明执行最后一次以“ls”开头的命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="嘿嘿嘿" scheme="http://yoursite.com/categories/%E5%98%BF%E5%98%BF%E5%98%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么你要写博客？（转自知乎）</title>
    <link href="http://yoursite.com/2018/09/06/1/"/>
    <id>http://yoursite.com/2018/09/06/1/</id>
    <published>2018-09-06T12:19:13.000Z</published>
    <updated>2018-09-06T12:21:37.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个选择"><a href="#一个选择" class="headerlink" title="一个选择"></a>一个选择</h2><p>我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？</p><p>我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。</p><p>判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。</p><p>大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？</p><p>所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。</p><p>注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。</p><h2 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h2><p>写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的：</p><ul><li>不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……；</li><li>有目的地写，要务实，追求质量；</li><li>承认真实的自己，不要吹嘘，不要装逼，无需讨好读者；</li><li>记录自己学习、思考、总结的过程；</li><li>分享你的故事、所得、感想、经验；</li></ul><h3 id="提供持续学习的动力"><a href="#提供持续学习的动力" class="headerlink" title="提供持续学习的动力"></a>提供持续学习的动力</h3><p>例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。</p><h3 id="积累更多的知识"><a href="#积累更多的知识" class="headerlink" title="积累更多的知识"></a>积累更多的知识</h3><p>写并不是单纯的写。</p><p>例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。</p><p>例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。</p><h3 id="提高将事情讲清楚的能力"><a href="#提高将事情讲清楚的能力" class="headerlink" title="提高将事情讲清楚的能力"></a>提高将事情讲清楚的能力</h3><p>很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。</p><blockquote><p>如果一件事情你不能讲清楚，十有八九你还没有完全理解。</p></blockquote><p>将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。</p><h3 id="分享带来的连锁反应"><a href="#分享带来的连锁反应" class="headerlink" title="分享带来的连锁反应"></a>分享带来的连锁反应</h3><blockquote><p>“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》</p></blockquote><p>互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。</p><h3 id="帮你找到志同道合的人"><a href="#帮你找到志同道合的人" class="headerlink" title="帮你找到志同道合的人"></a>帮你找到志同道合的人</h3><p>在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。</p><p>如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。</p><blockquote><p>即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》</p></blockquote><h3 id="记录成长"><a href="#记录成长" class="headerlink" title="记录成长"></a>记录成长</h3><p>隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。</p><p>更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！</p><h3 id="培养持续做一件事情的能力"><a href="#培养持续做一件事情的能力" class="headerlink" title="培养持续做一件事情的能力"></a>培养持续做一件事情的能力</h3><p>开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」</p><p>让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。</p><p>你不相信？你不试试你怎么知道？</p><p>默默地持续做一件事是一种难得的能力，也是一种难得的品质。</p><h3 id="讨论反思"><a href="#讨论反思" class="headerlink" title="讨论反思"></a>讨论反思</h3><p>每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。</p><p>互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。</p><h3 id="搜寻到你意想不到东西"><a href="#搜寻到你意想不到东西" class="headerlink" title="搜寻到你意想不到东西"></a>搜寻到你意想不到东西</h3><p>世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。</p><p>例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。</p><h3 id="一个人在做一件属于自己的事"><a href="#一个人在做一件属于自己的事" class="headerlink" title="一个人在做一件属于自己的事"></a>一个人在做一件属于自己的事</h3><p>很多你认为自己很牛逼的事情都是自己一个人做出来。</p><p>别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？</p><blockquote><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》</p></blockquote><h3 id="互联网的身份识别："><a href="#互联网的身份识别：" class="headerlink" title="互联网的身份识别："></a>互联网的身份识别：</h3><blockquote><p>一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。</p><p>这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>

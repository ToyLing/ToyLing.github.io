<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue前后端分离初体验]]></title>
    <url>%2F2018%2F10%2F10%2Fa%2F</url>
    <content type="text"><![CDATA[前端技术 vue.js vue-router(Vue Router 是 Vue.js 官方的路由管理器) axios element-ui webpack 后端技术 springboot mybatis shiro 为什么是springboot？ 首先先来简单的介绍一下Spring，它是目前Java生态中最广为人知、流行的企业级Web框架。不像其他一些框架仅聚焦在某个领域，Spring框架通过其容器化组件式管理及开发，可提供或定制各式各样的功能来满足企业化需求。 那么相较于Spring，Spring Boot的目标是更加容易的创建Spring应用、建立自动化、最少人为干预的生产级配置，真正意义做到开箱即用，并且对于新用户及Spring平台的用户极易上手，快速开发。 什么是MVVM？ 回顾一下Web开发的发展简史： 第一阶段: 网页三剑客，生猛的通过原生javascript直接操作Dom树; 第二阶段: JQuery诞生，配合前端MVC为代表的Backbone.js, 让我们可以优雅而简单的操作Dom树; 第三阶段: 后端架构升级为MVC，前后端分工更清晰，前端工程化、ECMAScript规范开始崭露头角; 第四阶段: 后端架构进入了微服务时代，前端架构不仅升级为MVVM，ES6更是成为目前事实上的标准; 在这里，我不想过于神化MVVM有多么的先进，JQuery为代表的MVC有多么的落后，但确实MVVM有着很多先进的特性: 低开销 易维护 可重用 为什么是vue？ Vue.js是MVVM设计模式中目前最火热的一个前端框架之一，除了性能表现优异之外，与类似React相比，更轻量级、更容易上手。 通过Vue中的“单文件组件”特性，更灵活的定义组件，不仅使代码结构更清晰，而且能与任何其他组件进行随意组合，更具复用性。 webpack是什么 Webpack提供了一整套前端工程自动化的解决方案 在这里通过一个简单登录小demo来演示前后段分离开发 生成vue项目1 安装node.js ​ 具体安装流程还是要去看node.js官网。如果安装完成，请在终端输入npm -v查看是否安装成功。 2、安装VueCLI脚手架 VueCLI能够帮助我们快速搭建一个webpack的项目。 在已经安装好node.js的前提上，在终端输入：npm install vue-cli -g开始安装VueCLI。如果安装完成，请在终端输入：vue查看是否安装成功 3 用 cmd 进入到你要存放项目的目录，我把项目放在D盘的VueProject文件夹下，运行 vue init webpack 你的项目名 依次为你的项目名称，项目描述，作者， nstall vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用 Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试 Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试 建议新手开始除了ESlint选no以外其他全部选yes，为什么？ 开了之后你就会发现多一个空格，多一个换行，都瞎几把标红，很蛋疼 配置完成之后你会发现项目存放处会多了一个tldemo文件夹，这就是你的前端项目了 cd tldemo npm install :安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。 npm run dev 好了，一个vue项目的HelloWord就出来了 前端项目安装element-ui和axios 123npm install element-uinpm install axios 前端项目目录 main.js 1234567891011121314151617181920212223import Vue from 'vue'import App from './App'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import router from './router/index.js'import VueRouter from 'vue-router'import axios from 'axios'Vue.prototype.$http = axiosVue.use(ElementUI)Vue.use(VueRouter)Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', render: c =&gt; c(App), router: router //注册router&#125;) main是webpack入口文件，这里我们引入 123import axios from 'axios'import ElementUI from 'element-ui'import VueRouter from 'vue-router' 路由 index.js 12345678910111213import Vue from 'vue'import Router from 'vue-router'import home from '../components/home'import login from '../components/login'Vue.use(Router)const routes= [ &#123; path :'/',component :login&#125;, &#123; path: '/home',component: home&#125;];const router=new Router(&#123; routes&#125;)export default router 如上就配置了，如果你访问localhost:8081/，那么就会自动路由跳转到login.vue组件中，提示我们登录;其中的/home表示，如果登录成功，就跳转到home.vue组件中，相当于登录成功后跳转到后台页面。 登录组件 login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;template&gt; &lt;el-form :model="loginForm" :rules="rules" ref ="loginForm" class="login-container" label-position="right"&gt; &lt;h3 class="login_title"&gt;登录&lt;/h3&gt; &lt;el-form-item prop="username"&gt; &lt;el-input v-model="loginForm.username" auto-complete="off" placeholder="账号"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="password"&gt; &lt;el-input type="password" v-model="loginForm.password" auto-complete="off" placeholder="密码"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-checkbox class="login_remember" v-model="checked" &gt;记住密码&lt;/el-checkbox&gt; &lt;el-form-item&gt; &lt;el-button type="primary" @click="submitForm('loginForm')"&gt;登录&lt;/el-button&gt; &lt;el-button @click="resetForm('loginForm')"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; serverData:&#123;&#125;, loginForm: &#123; username: '', password: '' &#125;, checked:true, rules: &#123; username : [ &#123; required: true ,message: '请输入用户名' , trigger: 'blur'&#125;, &#123; min: 3,max:10 ,message: '长度在3到10个字符' , trigger: 'blur'&#125; ], password : [ &#123; required: true ,message: '请输入密码' , trigger: 'blur'&#125;, ] &#125; &#125;; &#125;, methods:&#123; submitForm(loginForm) &#123; this.$refs[loginForm].validate((valid) =&gt; &#123; if (valid) &#123; this.$http.post('http://127.0.0.1:8080/login', &#123; username :this.loginForm.username, password :this.loginForm.password &#125;, ).then(response =&gt; &#123; console.log(response) if(response.data === 'index')&#123; this.$router.push(&#123;path :'home'&#125;); &#125;else&#123; console.log("登录失败"); &#125; &#125;) .catch(function (error) &#123; console.log(error) &#125;) &#125; else &#123; console.log('error submit!!'); return false; &#125; &#125;); &#125;, resetForm(loginForm) &#123; this.$refs[loginForm].resetFields(); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .login-container &#123; border-radius: 15px; background-clip: padding-box; margin: 180px auto; width: 350px; padding: 35px 35px 15px 35px; background: #fff; border: 1px solid #eaeaea; box-shadow: 0 0 25px #cac6c6; &#125; .login_title &#123; margin: 0px auto 40px auto; text-align: center; color: #505458; &#125; .login_remember &#123; margin: 0px 0px 35px 0px; text-align: left; &#125; .el-main &#123; background-color: #E9EEF3; color: #333; text-align: center; &#125; .el-header, .el-footer &#123; background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; &#125; .el-aside &#123; background-color: #D3DCE6; color: #333; text-align: center; line-height: 200px; &#125;&lt;/style&gt; 每个vue组件都是由三部分组成 在上面表单中，我们只需要关注 v-model=”loginForm.username” v-model=”loginForm.password” @click=”submitForm(‘loginForm’)” @click=”resetForm(‘loginForm’)” 首先this.$refs[loginForm].validate((valid)是element-ui提供的表单校验逻辑， 校验成功后通过axios发送post请求，请求成功，调用.then()回获取到成功的请求结果。index是从后端成功返回的结果，如果登陆成功就调用路由 $router.push({path :’home’})跳转到home组件（核心部分） home组件home.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2&gt;这是首页&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:"home"&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 前端界面 校验效果 正确账号密码为admin/123456 这时打开前端项目中的index.html 首页中没有引入js，css代码，但页面视图是怎样渲染出来的，是不是很神奇 没错就是通过我们.vue组件渲染出来的，是不是很有意思 跨域请求的问题 node.js提供的web服务器地址是：127.0.0.1:8081，但是我们后端Tomcat服务器的地址是：127.0.0.1:8080，而默认是不能在一个域中访问另一个域中的资源的，所以也就出现了跨域请求的概念。 解决跨域请求的方式也有很多，我这里在后端controller上加了@CrossOrigin注解 后端项目后端项目就相对比较简单，使用MyBatis Generator，编写controller MyBatis Generator 是MyBatis 官方出品的一款，用来自动生成MyBatis的 mapper、dao、entity 的框架，让我们省去规律性最强的一部分最基础的代码编写。 项目目录 Controller 12345678910111213141516171819202122232425@RestController@CrossOriginpublic class UserController &#123; @Autowired private UserloginMapper userloginMapper; @RequestMapping("/login") public String login(@RequestBody Map map) &#123; String username=map.get("username").toString(); String password =map.get("password").toString(); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken Token = new UsernamePasswordToken(username, password); try &#123; //执行登录 subject.login(Token); return "index"; &#125; catch (AuthenticationException e) &#123; return "login"; &#125; &#125;&#125; 这里使用了shiro安全框架具体请看张开涛《跟我学Shiro》 需要注意的是我这里用@RequestBody，之前用@RequestParam来接收前端传过来的参数，居然接受不到，用postman发的参数测的没问题，前端发的就接受不到，一脸懵逼 请求正文为Request Payload,请求头Content-Type: application/json，以这种方式请求，后台用@RequestParam是接收不到参数的，只能用@RequestBody，而axios默认是用Content-Type: application/json，这问题可以在前端解决，也可以在后端解决，在前端解决需要修改axios的默认配置 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; Request Payload请求： Request Payload的请求正文格式是json格式的字符串： { “loginName” : “admin”, “password” : “123456” } Form Data请求： Form Data的请求正文格式是用key=value&amp;key1=value2格式： loginName=admin&amp;password=123456 这里是深坑，坑了我好长时间 请求成功 好的一个简单的前后端分离登录功能就完成了 最后前前后后弄了半个月，我也在想一个那么垃圾的登录都能弄半个月，我是不是已经完了(⊙o⊙)…]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2018%2F09%2F11%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[最近在折腾Linux，之前大二学的忘得一干二净（其实考试也才刚及格，哈哈哈哈哈），重新看看吧。 Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是巨型项目都在使用linux。 ​ linux的特点​ - 免费的/开源​ - 支持多线程/多用户​ - 安全性好​ - 对内存和文件管理优越 关机命令 123shutdown -h now（立即进行关机） shutdown -r now （现在重新启动计算机） reboot （现在重新启动计算机） 进入桌面 1startx 用户登录 12登录时尽量少用root账户登录，因为它是系统管理员，最大的权限，难免操作失误。可以利用普通用户登录，登录后再用“su -”命令来切换成系统管理员身份 用户注销 1在提示符下输入logout即可 vi编辑器是linux下最有名的编辑器，也是我们学习linux必须掌握的工具，在linux下也可使用vi进行程序的开发，如Java程序，c程序 。输入i，进入到插入模式；输入Esc键，进入命令模式 ；输入冒号:wq 表示退出保存，:q!表示退出不保存 linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录，深刻理解linux文件目录是非常重要的 12345678910- / - root，存放root用户的相关文件 - home，存放普通用户的相关文件 - bin，存放常用命令的目录，如vi，su - sbin，要具有一定权限才可以使用命令 - mnt，默认挂载光驱和软驱的目录 - etc，存放配置的相关文件 - var，存放经常变化的文件，如网络连接的sock文件 - boot，存放引导系统启动的相关文件 - usr，安装一个软件的默认目录，相当于windows下的program files ​ 常用命令介绍 pwd，显示当前在哪个路径下 linux的用户管理 useradd 用户名，添加用户​ 【案例】useradd xiaoming passwd 用户名，为新用户设密码​ 【案例】passwd xiaoming，修改小明的密码 userdel 用户名，删除用户​ 【案例】userdel xiaoming，删除用户但保存用户主目录​ 【案例】userdel ‐ xiaoming，删除用户以及用户主目录 logout，当前用户推出who am i，当前用户是谁cd，改变目录ls，列出文件和目录ls ‐a，显示目录下的所有文件，包括隐藏文件ls ‐l，显示长列表格式mkdir，建立目录rmdir，删除空目录touch，建立空文件 cp，复制命令​ 【案例】cp ‐r dir1 dir2，递归复制命令（复制子目录信息） mv，移动文件和改文件名rm，删除文件和目录rm ‐rf *，删除所有内容，包含目录和文件，r表示递归，f表示强制ln，建立符号连接，类似于建立某个文件的快捷方式 ln ‐s 源目标​ 【案例】ln ‐s /etc/inittab inittab，inittab指向实际文件/etc/inittab inittab more，显示文件内容带分页，ctrl + page up上翻，长空格下翻less，显示文件内容带分页 grep，在文本中查询内容​ 【案例】假设存在某个文件test.Java中含有hanyang关键字，此时可以使用grep名命令来查找， grep n “hanyang” test.java，n表示在第n行出现 |，管道命令，在linux和unix系统，把上一个命令的结果交给|后面的命令处理​ 【案例】ls ‐l /etc/ | more man [command]，帮助，类似于dos中的help find，搜索文件及目录。在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而“find”命令可以解决上述问题 在特定的目录下搜索并显示指定名称的文件和目录 123456【案例】find / -name man：意思是说从根目录开始搜索名称为man的文件或目录 - 搜索一段时间内被存取/变更的文件或目录 【案例】find /home -amin -10：十分钟内存取的文件或目录 【案例】find /home -atime -10：十小时内存取的文件或目录 【案例】find /home -cmin -10：十分钟内更改过的文件或目录 【案例】find /home -ctime +10：十小时前更改过的文件或目录 搜索指定大小的文件 1【案例】find /home -size +10k：意思是说查找/home目录下大小为10k的文件 重定向命令 1234- ls -l &gt; a.txt，列表的内容写入文件a.txt中（覆盖写） - ls -al &gt;&gt; aa.txt，列表的内容追加到文件aa.txt的末尾 - 从文件中输入信息：database_program &lt; database_data - en，查看环境变量 压缩和解压 12345678910111213141516171819202122232425262728- 以zip和unzip处理.zip文件 - zip命令的基本使用方法 - zip file.zip *：zip后接压缩后的文件名，在它的后面输入要压缩的文件即可 - 压缩后，自动删除原文件 【案例】zip m file.zip to.txt：把to.txt文件压缩成file.zip文件，to.txt会自动删除的 - 将子目录一起压缩 【案例】zip ‐r file.zip *：将当前目录下的子目录一起压缩 - 忽略子目录的内容 【案例】zip ‐j file.zip * - 将已压缩的或没有必要压缩的文件去掉 【案例】zip ‐n .mpg: .jpg: .gif：第一种文件中间要用“：”分开 - 压缩某一日之后的文件 【案例】zip ‐t 102002 file.zip：将当前目录下在2002年10月20日之后文件压缩 - 不压缩链接文件的原文件 【案例】zip ‐y file.zip * - 压缩率问题，-1~-9，其中-9的压缩率最高 【案例】zip -9 file.zip * - 将不需要压缩的文件排除在外 【案例】zip file.zip * -x file2.txt：在压缩时，将当前目录内的file2.txt文件排除在外 - 以unzip命令进行.zip文件的解压缩 - 直接解压缩文件 【案例】unzip file.zip - 排除不需要解压缩的文件 【案例】unzip file.zip ‐x file2：除了file2文件外，其他的文件都解压缩 - 查看压缩包的内容 【案例】unzip ‐Z file.zip：查看file.zip压缩包的内容，也可以使用“-l” “-v”来查看压缩包的内容 - 以gzip和gunzip处理.gz文件 ​ 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念 。1）所有者：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者。用ls ‐ahl命令可以看到文件的所有者。也可以使用chown 用户名 文件名来修改文件的所有者。2）文件所在组：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组，用ls ‐ahl命令可以看到文件的所有组，也可以使用chgrp 组名 文件名来修改文件所在的组。3）其它组：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。 文件权限 1234567891011121314151617ls -l中显示的内容如下： -rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc - 10个字符确定不同用户能对文件干什么 - 第一个字符代表文件（-）、目录（d），链接（l） - 其余字符每3个一组（rwx），读（r）、写（w）、执行（x） - 第一组rwx：文件所有者的权限是读、写和执行 - 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行 - 第三组r--：不与文件所有者同组的其他用户的权限是读不能写和执行 也可用数字表示为：r=4，w=2，x=1 因此rwx=4+2+1=7 - 1 表示连接的文件数 - root 表示用户 - root表示用户所在的组 - 1213 表示文件大小（字节） - Feb 2 09:39 表示最后修改日期 - abc 表示文件名 改变权限的命令 12345chmod 改变文件或目录的权限 chmod 755 abc：赋予abc权限rwxr-xr-x chmod u=rwx，g=rx，o=rx abc：同上u=用户权限，g=组权限，o=不同组其他用户权限 chmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限 chmod a+r abc：给所有用户添加读的权限 改变所有者（chown）和用户组（chgrp）命令 1234chown xiaoming abc：改变abc的所有者为xiaoming chgrp root abc：改变abc所属的组为root chown root ./abc：改变abc这个目录的所有者是root chown ‐R root ./abc：改变abc这个目录及其下面所有的文件和目录的所有者是root 改变用户所在组 1234在添加用户时，可以指定将该用户添加到哪个组中，同样用root的管理权限可以改变某个用户所在的组 - usermod ‐g 组名 用户名 你可以用 - usermod ‐d 目录名 用户名，改变该用户登录的初始目录 linux分区详解 硬盘的分区主要分为基本分区（Primary Portion）和扩展分区（Extension Portion）两种。 只是针对一个硬盘来讲，基本分区和扩展分区的数目之和不能大于4个，且基本分区可以马上被使用但不能再分区。扩展分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。那么有扩展分区再分下去的是什么呢？它就是逻辑分区（Logical Portion），而且逻辑分区没有数量上限制 对windows用户来说，有几个分区就有几个驱动器，并且每个分区都会获得一个字母标识符，然后就可以选用这个字母来指定在这个分区上的文件和目录。它们的文件结构都是独立的，非常好理解。但对这些用户初上手Redhat Linux，可就有点恼人了。 因为对Redhat Linux用户来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录、一个独立且唯一的文件结构。Redhat Linux中每个分区都是用来组成整个文件系统的一部分。因为它采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来。这时要载入的那个分区将使它的存储空间在这个目录下获得。 几个重要命令 挂载命令 mount [-parameters][设备名称] [挂载点] 卸载命令 umount [挂载点] 查看磁盘使用情况 df [-parameters]- df -h- df ‐l- df [目录全路径]，查看某个目录是在哪个分区 查看linux系统分区具体情况 fdisk ‐l shell编程 12345678其实作为命令语言互动式地解释和执行用户输入的命令只是shell功能的一个方面。shell还可以用来进行程序设计。它提供了定义变量和参数的手段以及丰富的程序控制结构。使用shell编程类似于DOS中批处理文件，称为shell script，又叫shell程序或shell命令文件。shell脚本文件： - 是一个文本文件 - 命令的集合 - 有执行的权限 - 执行方式（./文件名） 用export可以临时加入一个系统路径，如export PATH=$PATH:$HOME/bin:/root/test/t1，输出环境PATH，引用原来的值$，PATH，$HOME表示工作主目录，:是路径分隔符 shell通配符 - 代表多个字母或数字- ?代表一个字母或数字【案例】ls a ls a? ls f080[1-6].tif - 转义字符\ 【案例】ls /mnt/win1/My\Documents - 单引号：不处理任何变量和命令 【案例】echo ‘Welcome $NAME, the date is date ’ - 双引号：处理变量但不处理命令 【案例】echo “Welcome $NAME, the date is date “ - 反引号：把引号中的每个单词作为一个命令，如果是变量则先求值然后作为一个命令处理 【案例】echo “Welcome $NAME, the date is date “ 查阅历史记录 - history，查看使用过的命令的历史记录- history 5，此项说明会显示最近使用的5个命令- !5，此项说明执行历史编号为5的命令 - !ls，此项说明执行最后一次以“ls”开头的命令]]></content>
      <categories>
        <category>嘿嘿嘿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么你要写博客？（转自知乎）]]></title>
    <url>%2F2018%2F09%2F06%2F1%2F</url>
    <content type="text"><![CDATA[一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。 大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？ 所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。 注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。 博客的内容写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的： 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……； 有目的地写，要务实，追求质量； 承认真实的自己，不要吹嘘，不要装逼，无需讨好读者； 记录自己学习、思考、总结的过程； 分享你的故事、所得、感想、经验； 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 积累更多的知识写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应 “通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 搜寻到你意想不到东西世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别： 一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
